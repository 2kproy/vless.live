<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Генератор инбаунтов ГенаНа — vless.live</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Space+Grotesk:wght@500;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-1: #0c0f1a;
      --bg-2: #11182b;
      --bg-3: #0c0f1a;
      --accent: #44d1ff;
      --accent-2: #ff4ff6;
      --glow: 0 0 20px rgba(68, 209, 255, 0.6);
      --text: #d9e6ff;
      --muted: #8aa2d3;
      --border: rgba(68, 209, 255, 0.35);
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: 'Inter', 'Space Grotesk', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: radial-gradient(circle at 10% 20%, rgba(68, 209, 255, 0.12) 0, transparent 35%),
                  radial-gradient(circle at 90% 10%, rgba(255, 79, 246, 0.14) 0, transparent 40%),
                  radial-gradient(circle at 50% 80%, rgba(68, 209, 255, 0.18) 0, transparent 45%),
                  linear-gradient(135deg, var(--bg-1), var(--bg-2), var(--bg-3));
      color: var(--text);
      overflow-x: hidden;
    }

    .scan-lines::before {
      content: "";
      pointer-events: none;
      position: fixed;
      inset: 0;
      background: repeating-linear-gradient(
        to bottom,
        rgba(255, 255, 255, 0.03),
        rgba(255, 255, 255, 0.03) 1px,
        transparent 1px,
        transparent 3px
      );
      mix-blend-mode: overlay;
      opacity: 0.5;
      animation: scan 6s linear infinite;
      z-index: 1;
    }

    @keyframes scan {
      0% { transform: translateY(-10%); }
      100% { transform: translateY(10%); }
    }

    .floating-runes {
      position: fixed;
      inset: 0;
      pointer-events: none;
      overflow: hidden;
      z-index: 0;
    }

    .rune {
      position: absolute;
      font-size: 22px;
      color: rgba(68, 209, 255, 0.2);
      animation: float 10s ease-in-out infinite;
      text-shadow: 0 0 12px rgba(68, 209, 255, 0.6);
    }

    @keyframes float {
      0% { transform: translateY(20px) scale(1); opacity: 0; }
      20% { opacity: 1; }
      50% { transform: translateY(-10px) scale(1.1); }
      100% { transform: translateY(-50px) scale(0.9); opacity: 0; }
    }

    header {
      position: relative;
      padding: 48px 24px 24px;
      text-align: center;
      z-index: 2;
    }

    .hero {
      position: relative;
      max-width: 1100px;
      margin: 0 auto;
      padding: 32px 24px;
      backdrop-filter: blur(6px);
      background: rgba(14, 19, 38, 0.7);
      border: 1px solid var(--border);
      box-shadow: var(--glow), 0 30px 80px rgba(0,0,0,0.45);
      border-radius: 20px;
    }

    .hero.compact {
      padding: 28px 24px;
    }

    .hero h1 {
      font-family: 'Space Grotesk', 'Inter', sans-serif;
      font-size: clamp(32px, 5vw, 56px);
      margin: 0 0 10px;
      letter-spacing: -1px;
      background: linear-gradient(120deg, var(--accent), var(--accent-2));
      -webkit-background-clip: text;
      color: transparent;
      text-shadow: var(--glow);
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 14px;
      border-radius: 999px;
      background: rgba(68, 209, 255, 0.14);
      color: var(--text);
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      font-size: 12px;
      border: 1px solid var(--border);
      box-shadow: var(--glow);
      margin-bottom: 14px;
    }

    .cta {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      padding: 12px 18px;
      background: linear-gradient(120deg, var(--accent), var(--accent-2));
      color: #0b0f1a;
      font-weight: 700;
      border-radius: 14px;
      border: none;
      cursor: pointer;
      text-decoration: none;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      box-shadow: 0 10px 30px rgba(68, 209, 255, 0.45);
      transition: transform 180ms ease, box-shadow 180ms ease, background 180ms ease;
      font-size: 14px;
    }

    .cta.secondary {
      background: transparent;
      color: var(--text);
      border: 1px solid var(--border);
      box-shadow: none;
    }

    .cta:hover {
      transform: translateY(-2px) scale(1.01);
      box-shadow: 0 16px 38px rgba(255, 79, 246, 0.35);
    }

    .cta-group {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 12px;
      flex-wrap: wrap;
    }

    main {
      position: relative;
      z-index: 2;
      padding: 12px 20px 48px;
      max-width: 1200px;
      margin: 0 auto;
    }

    .panel {
      background: rgba(16, 23, 43, 0.85);
      border: 1px solid var(--border);
      border-radius: 18px;
      padding: 22px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.55);
    }

    .panel + .panel { margin-top: 18px; }

    .section-head {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 14px;
      flex-wrap: wrap;
      margin-bottom: 14px;
    }

    .section-head h2 {
      margin: 0;
      font-size: 22px;
      letter-spacing: -0.3px;
    }

    .section-head p {
      margin: 0;
      color: var(--muted);
      max-width: 620px;
      line-height: 1.6;
    }

    .form-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 14px;
    }

    .field {
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 12px;
      border: 1px solid rgba(68, 209, 255, 0.25);
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.02);
    }

    label { font-weight: 700; font-size: 14px; }

    .muted { color: var(--muted); font-weight: 400; font-size: 13px; line-height: 1.4; }

    input, select, textarea {
      background: rgba(255, 255, 255, 0.04);
      border: 1px solid rgba(68, 209, 255, 0.25);
      color: var(--text);
      padding: 10px;
      border-radius: 10px;
      font-size: 14px;
      font-family: 'Inter', sans-serif;
      width: 100%;
    }

    textarea {
      min-height: 320px;
      resize: vertical;
      font-family: 'JetBrains Mono', 'SFMono-Regular', Menlo, Consolas, monospace;
      line-height: 1.5;
    }

    .two-col { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(68, 209, 255, 0.12);
      border: 1px solid rgba(68, 209, 255, 0.3);
      color: var(--text);
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .chips {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .checkbox-row {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      color: var(--text);
    }

    .actions {
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
      margin-top: 12px;
    }

    .status { color: var(--muted); font-size: 13px; }

    @media (max-width: 720px) {
      header { padding: 28px 14px 12px; }
      main { padding: 8px 14px 36px; }
    }
  </style>
</head>
<body class="scan-lines">
  <div class="floating-runes" aria-hidden="true"></div>

  <header>
    <div class="hero compact">
      <div class="badge">ГенаНа / inbound lab</div>
      <h1>Генератор инбаунтов для Xray</h1>
      <p class="muted">Вдохновлён мастером из панели 3x-ui. Заполняй поля как в родной форме, выбирай протокол и транспорт — на выходе получишь корректный inbound для ядра Xray.</p>
      <div class="cta-group">
        <a class="cta secondary" href="/">Назад на vless.live</a>
        <button class="cta" id="generateBtn" type="button">Собрать конфиг</button>
      </div>
    </div>
  </header>

  <main>
    <section class="panel">
      <div class="section-head">
        <div>
          <h2>Основные поля</h2>
          <p>Совпадают с генератором 3x-ui: ремарка, протокол, порт, слушающий адрес и параметры клиентов.</p>
        </div>
        <span class="pill">Все протоколы и транспорты</span>
      </div>
      <form id="genForm" class="form-grid">
        <div class="field">
          <label for="remark">Ремарка / tag</label>
          <input id="remark" placeholder="VLESS_TCP_REALITY">
          <span class="muted">Нужна для идентификации инбаунда и fallback.</span>
        </div>
        <div class="field">
          <label for="listen">Listen</label>
          <input id="listen" placeholder="0.0.0.0">
          <span class="muted">Оставь пустым для значения по умолчанию.</span>
        </div>
        <div class="field">
          <label for="port">Порт</label>
          <input id="port" type="number" placeholder="443" min="1" max="65535" required>
        </div>
        <div class="field">
          <label for="protocol">Протокол</label>
          <select id="protocol">
            <option value="vless">VLESS</option>
            <option value="vmess">VMess</option>
            <option value="trojan">Trojan</option>
            <option value="shadowsocks">Shadowsocks</option>
            <option value="socks">Socks</option>
            <option value="http">HTTP</option>
            <option value="dokodemo-door">Dokodemo-door</option>
          </select>
        </div>

        <div class="field" data-protocol="vless vmess trojan shadowsocks">
          <label for="clientEmail">Email (для клиента)</label>
          <input id="clientEmail" placeholder="user@vless.live">
        </div>

        <div class="field" data-protocol="vless vmess">
          <label for="clientId">UUID</label>
          <div class="actions">
            <input id="clientId" placeholder="auto" aria-label="UUID">
            <button class="cta secondary" id="uuidBtn" type="button">Сгенерировать UUID</button>
          </div>
        </div>

        <div class="field" data-protocol="vmess">
          <label for="alterId">alterId</label>
          <input id="alterId" type="number" min="0" max="64" value="0">
        </div>

        <div class="field" data-protocol="vless">
          <label for="vlessFlow">Flow</label>
          <select id="vlessFlow">
            <option value="">Без flow</option>
            <option value="xtls-rprx-vision">xtls-rprx-vision</option>
            <option value="xtls-rprx-vision-udp443">xtls-rprx-vision-udp443</option>
          </select>
        </div>

        <div class="field" data-protocol="trojan">
          <label for="trojanPassword">Пароль Trojan</label>
          <input id="trojanPassword" placeholder="strong-password">
        </div>

        <div class="field" data-protocol="shadowsocks">
          <label for="ssMethod">Shadowsocks method</label>
          <select id="ssMethod">
            <option value="aes-128-gcm">aes-128-gcm</option>
            <option value="aes-256-gcm">aes-256-gcm</option>
            <option value="chacha20-ietf-poly1305">chacha20-ietf-poly1305</option>
            <option value="2022-blake3-aes-128-gcm">2022-blake3-aes-128-gcm</option>
            <option value="2022-blake3-aes-256-gcm">2022-blake3-aes-256-gcm</option>
            <option value="2022-blake3-chacha20-poly1305">2022-blake3-chacha20-poly1305</option>
          </select>
        </div>

        <div class="field" data-protocol="shadowsocks">
          <label for="ssPassword">Пароль SS</label>
          <input id="ssPassword" placeholder="password">
        </div>

        <div class="field" data-protocol="socks http">
          <label for="socksAuth">Авторизация</label>
          <select id="socksAuth">
            <option value="noauth">Без авторизации</option>
            <option value="password">Логин/пароль</option>
          </select>
          <div class="two-col">
            <input id="socksUser" placeholder="user" aria-label="Логин">
            <input id="socksPass" placeholder="pass" aria-label="Пароль">
          </div>
        </div>

        <div class="field" data-protocol="socks">
          <label class="checkbox-row"><input type="checkbox" id="socksUdp" checked>Включить UDP</label>
        </div>

        <div class="field" data-protocol="http">
          <label class="checkbox-row"><input type="checkbox" id="httpTransparent">allowTransparent</label>
          <span class="muted">Для HTTP авторизация подтягивается из полей выше.</span>
        </div>

        <div class="field" data-protocol="dokodemo-door">
          <label for="dokoAddress">Адрес Dokodemo-door</label>
          <input id="dokoAddress" placeholder="example.com или 1.1.1.1">
        </div>

        <div class="field" data-protocol="dokodemo-door">
          <label for="dokoPort">Порт Dokodemo-door</label>
          <input id="dokoPort" type="number" placeholder="443" min="1" max="65535">
        </div>

        <div class="field" data-protocol="dokodemo-door">
          <label for="dokoNetwork">Сети</label>
          <input id="dokoNetwork" placeholder="tcp,udp">
          <label class="checkbox-row"><input type="checkbox" id="dokoRedirect">followRedirect</label>
        </div>
      </form>
    </section>

    <section class="panel">
      <div class="section-head">
        <div>
          <h2>Транспорт</h2>
          <p>Полный список сетей как в 3x-ui: TCP, WS, HTTPUpgrade, mKCP, QUIC, gRPC и SplitHTTP.</p>
        </div>
        <span class="pill">Stream settings</span>
      </div>
      <div class="form-grid">
        <div class="field">
          <label for="network">Network</label>
          <select id="network">
            <option value="tcp">tcp</option>
            <option value="ws">ws</option>
            <option value="httpupgrade">httpupgrade</option>
            <option value="kcp">kcp</option>
            <option value="quic">quic</option>
            <option value="grpc">grpc</option>
            <option value="splithttp">splithttp</option>
          </select>
        </div>

        <div class="field" data-network="tcp">
          <label class="checkbox-row"><input type="checkbox" id="acceptProxy">acceptProxyProtocol</label>
        </div>

        <div class="field" data-network="ws">
          <label for="wsPath">WebSocket path</label>
          <input id="wsPath" placeholder="/ws" value="/ws">
          <input id="wsHost" placeholder="Host">
        </div>

        <div class="field" data-network="httpupgrade">
          <label for="httpPath">HTTPUpgrade path</label>
          <input id="httpPath" placeholder="/">
          <input id="httpHost" placeholder="Host">
        </div>

        <div class="field" data-network="grpc">
          <label for="grpcService">gRPC serviceName</label>
          <input id="grpcService" placeholder="GunService">
          <label class="checkbox-row"><input type="checkbox" id="grpcMulti">multiMode</label>
        </div>

        <div class="field" data-network="kcp">
          <label for="kcpSeed">mKCP seed</label>
          <input id="kcpSeed" placeholder="seed">
          <select id="kcpType">
            <option value="none">none</option>
            <option value="srtp">srtp</option>
            <option value="utp">utp</option>
            <option value="wechat-video">wechat-video</option>
            <option value="dtls">dtls</option>
            <option value="wireguard">wireguard</option>
          </select>
        </div>

        <div class="field" data-network="quic">
          <label for="quicSecurity">QUIC security</label>
          <input id="quicSecurity" placeholder="none">
          <input id="quicKey" placeholder="key">
          <select id="quicType">
            <option value="none">none</option>
            <option value="srtp">srtp</option>
            <option value="utp">utp</option>
            <option value="wechat-video">wechat-video</option>
            <option value="dtls">dtls</option>
            <option value="wireguard">wireguard</option>
          </select>
        </div>

        <div class="field" data-network="splithttp">
          <label for="splitHost">SplitHTTP host</label>
          <input id="splitHost" placeholder="cdn.example.com">
          <label for="splitPath">SplitHTTP path</label>
          <input id="splitPath" placeholder="/">
          <label for="splitConcurrency">Concurrency</label>
          <input id="splitConcurrency" type="number" value="4" min="1" max="32">
        </div>
      </div>
    </section>

    <section class="panel">
      <div class="section-head">
        <div>
          <h2>Безопасность & Sniffing</h2>
          <p>XTLS/Reality и TLS настройки как в панели. Сниффинг по http/tls/quic и опциональный metadataOnly.</p>
        </div>
        <span class="pill">TLS / Reality</span>
      </div>
      <div class="form-grid">
        <div class="field">
          <label for="security">Security</label>
          <select id="security">
            <option value="none">none</option>
            <option value="tls">tls</option>
            <option value="reality">reality</option>
          </select>
        </div>

        <div class="field" data-security="tls">
          <label for="tlsServer">serverName</label>
          <input id="tlsServer" placeholder="example.com">
          <label for="tlsAlpn">ALPN (через запятую)</label>
          <input id="tlsAlpn" placeholder="h2,http/1.1">
        </div>

        <div class="field" data-security="reality">
          <label for="realityDest">Reality dest</label>
          <input id="realityDest" placeholder="example.com:443">
          <label for="realityServerNames">serverNames (через запятую)</label>
          <input id="realityServerNames" placeholder="example.com,cdn.example.com">
          <label for="realityPrivateKey">privateKey</label>
          <input id="realityPrivateKey" placeholder="GENERATE WITH x25519">
          <label for="realityShortIds">shortIds (через запятую)</label>
          <input id="realityShortIds" placeholder="1d233d">
          <label for="realityFingerprint">fingerprint</label>
          <input id="realityFingerprint" placeholder="chrome" value="chrome">
          <label for="realitySpider">spiderX</label>
          <input id="realitySpider" placeholder="/">
        </div>

        <div class="field">
          <label class="checkbox-row"><input type="checkbox" id="sniffing" checked>Sniffing enabled</label>
          <label class="checkbox-row"><input type="checkbox" id="metadataOnly">metadataOnly</label>
          <div class="chips">
            <label class="checkbox-row"><input type="checkbox" class="dest-override" value="http" checked>http</label>
            <label class="checkbox-row"><input type="checkbox" class="dest-override" value="tls" checked>tls</label>
            <label class="checkbox-row"><input type="checkbox" class="dest-override" value="quic">quic</label>
            <label class="checkbox-row"><input type="checkbox" class="dest-override" value="fakedns">fakedns</label>
          </div>
        </div>
      </div>
    </section>

    <section class="panel">
      <div class="section-head">
        <div>
          <h2>Результат</h2>
          <p>Ниже готовый JSON фрагмент для блока <code>inbounds</code>. Можно сразу добавить в config.json Xray.</p>
        </div>
        <div class="actions">
          <button class="cta" id="copyBtn" type="button">Скопировать</button>
          <span class="status" id="status">Ожидает сборки…</span>
        </div>
      </div>
      <textarea id="output" spellcheck="false" aria-label="Сгенерированный инбаунд"></textarea>
    </section>
  </main>

  <script>
    const protocolSelect = document.getElementById('protocol');
    const networkSelect = document.getElementById('network');
    const securitySelect = document.getElementById('security');
    const output = document.getElementById('output');
    const statusEl = document.getElementById('status');

    const protocolFields = document.querySelectorAll('[data-protocol]');
    const networkFields = document.querySelectorAll('[data-network]');
    const securityFields = document.querySelectorAll('[data-security]');

    const destCheckboxes = document.querySelectorAll('.dest-override');

    const toggleVisibility = (fields, current) => {
      fields.forEach(el => {
        const variants = el.dataset.protocol || el.dataset.network || el.dataset.security;
        const list = variants.split(/\s+/);
        el.style.display = list.includes(current) ? 'flex' : 'none';
      });
    };

    const cleanObject = (value) => {
      if (Array.isArray(value)) {
        return value
          .map(cleanObject)
          .filter(v => v !== undefined && v !== null && !(typeof v === 'object' && Object.keys(v).length === 0));
      }
      if (value && typeof value === 'object') {
        const result = {};
        Object.entries(value).forEach(([k, v]) => {
          const cleaned = cleanObject(v);
          if (cleaned !== undefined && cleaned !== '' && !(Array.isArray(cleaned) && cleaned.length === 0) && !(typeof cleaned === 'object' && Object.keys(cleaned).length === 0)) {
            result[k] = cleaned;
          }
        });
        return result;
      }
      if (value === '' || value === undefined || value === null) return undefined;
      return value;
    };

    const parseList = (val) => (val || '').split(',').map(v => v.trim()).filter(Boolean);

    const buildSettings = () => {
      const protocol = protocolSelect.value;
      const email = document.getElementById('clientEmail').value.trim();
      switch (protocol) {
        case 'vless':
          return {
            clients: [{ id: document.getElementById('clientId').value.trim(), email, flow: document.getElementById('vlessFlow').value || undefined }],
            decryption: 'none'
          };
        case 'vmess':
          return {
            clients: [{ id: document.getElementById('clientId').value.trim(), email, alterId: Number(document.getElementById('alterId').value || 0) }],
            disableInsecureEncryption: true
          };
        case 'trojan':
          return {
            clients: [{ password: document.getElementById('trojanPassword').value.trim(), email }]
          };
        case 'shadowsocks':
          return {
            clients: [{ method: document.getElementById('ssMethod').value, password: document.getElementById('ssPassword').value.trim(), email }],
            network: 'tcp,udp'
          };
        case 'socks': {
          const auth = document.getElementById('socksAuth').value;
          const accounts = auth === 'password'
            ? [{ user: document.getElementById('socksUser').value.trim(), pass: document.getElementById('socksPass').value.trim() }]
            : [];
          return {
            auth,
            udp: document.getElementById('socksUdp').checked,
            accounts
          };
        }
        case 'http': {
          const auth = document.getElementById('socksAuth').value;
          const accounts = auth === 'password'
            ? [{ user: document.getElementById('socksUser').value.trim(), pass: document.getElementById('socksPass').value.trim() }]
            : [];
          return {
            accounts,
            allowTransparent: document.getElementById('httpTransparent').checked
          };
        }
        case 'dokodemo-door':
          return {
            address: document.getElementById('dokoAddress').value.trim(),
            port: Number(document.getElementById('dokoPort').value || 0),
            network: document.getElementById('dokoNetwork').value.trim() || 'tcp,udp',
            followRedirect: document.getElementById('dokoRedirect').checked
          };
        default:
          return {};
      }
    };

    const buildStreamSettings = () => {
      const network = networkSelect.value;
      const base = { network };

      if (network === 'tcp') {
        if (document.getElementById('acceptProxy').checked) {
          base.tcpSettings = { acceptProxyProtocol: true };
        }
      }
      if (network === 'ws') {
        base.wsSettings = {
          path: document.getElementById('wsPath').value.trim() || '/',
          headers: document.getElementById('wsHost').value.trim() ? { Host: document.getElementById('wsHost').value.trim() } : undefined
        };
      }
      if (network === 'httpupgrade') {
        base.httpupgradeSettings = {
          path: document.getElementById('httpPath').value.trim() || '/',
          host: document.getElementById('httpHost').value.trim()
        };
      }
      if (network === 'grpc') {
        base.grpcSettings = {
          serviceName: document.getElementById('grpcService').value.trim(),
          multiMode: document.getElementById('grpcMulti').checked
        };
      }
      if (network === 'kcp') {
        base.kcpSettings = {
          seed: document.getElementById('kcpSeed').value.trim(),
          header: { type: document.getElementById('kcpType').value }
        };
      }
      if (network === 'quic') {
        base.quicSettings = {
          security: document.getElementById('quicSecurity').value.trim() || 'none',
          key: document.getElementById('quicKey').value.trim(),
          header: { type: document.getElementById('quicType').value }
        };
      }
      if (network === 'splithttp') {
        base.splitHttpSettings = {
          host: parseList(document.getElementById('splitHost').value),
          path: document.getElementById('splitPath').value.trim() || '/',
          concurrency: Number(document.getElementById('splitConcurrency').value || 4)
        };
      }

      const security = securitySelect.value;
      base.security = security;

      if (security === 'tls') {
        base.tlsSettings = {
          serverName: document.getElementById('tlsServer').value.trim(),
          alpn: parseList(document.getElementById('tlsAlpn').value)
        };
      }

      if (security === 'reality') {
        base.realitySettings = {
          show: false,
          dest: document.getElementById('realityDest').value.trim(),
          serverNames: parseList(document.getElementById('realityServerNames').value),
          privateKey: document.getElementById('realityPrivateKey').value.trim(),
          shortIds: parseList(document.getElementById('realityShortIds').value),
          fingerprint: document.getElementById('realityFingerprint').value.trim() || 'chrome',
          spiderX: document.getElementById('realitySpider').value.trim() || '/'
        };
      }

      return base;
    };

    const buildSniffing = () => {
      if (!document.getElementById('sniffing').checked) return undefined;
      const overrides = Array.from(destCheckboxes)
        .filter(cb => cb.checked)
        .map(cb => cb.value);
      return {
        enabled: true,
        destOverride: overrides,
        metadataOnly: document.getElementById('metadataOnly').checked
      };
    };

    const generateInbound = () => {
      const inbound = {
        tag: document.getElementById('remark').value.trim() || `${protocolSelect.value.toUpperCase()}_${Date.now()}`,
        listen: document.getElementById('listen').value.trim(),
        port: Number(document.getElementById('port').value || 0),
        protocol: protocolSelect.value,
        settings: buildSettings(),
        streamSettings: buildStreamSettings(),
        sniffing: buildSniffing()
      };

      const cleaned = cleanObject(inbound);
      output.value = JSON.stringify(cleaned, null, 2);
      statusEl.textContent = 'Готово! Инбаунд сгенерирован.';
    };

    protocolSelect.addEventListener('change', () => toggleVisibility(protocolFields, protocolSelect.value));
    networkSelect.addEventListener('change', () => toggleVisibility(networkFields, networkSelect.value));
    securitySelect.addEventListener('change', () => toggleVisibility(securityFields, securitySelect.value));

    document.getElementById('uuidBtn').addEventListener('click', () => {
      const target = document.getElementById('clientId');
      target.value = crypto.randomUUID();
    });

    document.getElementById('generateBtn').addEventListener('click', generateInbound);
    document.getElementById('genForm').addEventListener('submit', (e) => {
      e.preventDefault();
      generateInbound();
    });

    document.getElementById('copyBtn').addEventListener('click', async () => {
      if (!output.value) return;
      await navigator.clipboard.writeText(output.value);
      statusEl.textContent = 'Скопировано в буфер обмена';
    });

    const init = () => {
      if (!document.getElementById('clientId').value && crypto.randomUUID) {
        document.getElementById('clientId').value = crypto.randomUUID();
      }
      if (!document.getElementById('port').value) {
        document.getElementById('port').value = 443;
      }
      if (!document.getElementById('remark').value) {
        document.getElementById('remark').value = 'VLESS_TCP_REALITY';
      }
      toggleVisibility(protocolFields, protocolSelect.value);
      toggleVisibility(networkFields, networkSelect.value);
      toggleVisibility(securityFields, securitySelect.value);
      generateInbound();
    };

    init();

    const runeChars = ['✦','✧','✺','✼','✹','✶'];
    const runeContainer = document.querySelector('.floating-runes');
    for (let i = 0; i < 26; i++) {
      const span = document.createElement('span');
      span.className = 'rune';
      span.textContent = runeChars[Math.floor(Math.random() * runeChars.length)];
      span.style.left = `${Math.random() * 100}%`;
      span.style.top = `${Math.random() * 100}%`;
      span.style.animationDelay = `${Math.random() * 6}s`;
      span.style.opacity = 0;
      runeContainer.appendChild(span);
    }
  </script>
</body>
</html>
